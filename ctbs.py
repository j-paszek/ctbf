import shutil
import subprocess
import os.path
import sys
import time
from copy import deepcopy

from simulator import CancerCellEvolutionSimulator
from reconstructor import build_evolution_tree, visualize_tree_plotly
from evaluator import grf_tree

IN_FILE_NAME = "biopsy.txt"
OUT_FILE_NAME = "cnp_distance_matrix.txt"
cnp2cnp_FOLDER = r"/Users/voronwe/Work/PyCharmProjects/cnp2cnp/examples"
cnp2cnp_FILE = r"/Users/voronwe/Work/PyCharmProjects/cnp2cnp/cnp2cnp.py"

class Timer:
    def __init__(self, label, collector=None, verbose=False):
        self.label = label
        self.collector = collector
        self.verbose = verbose
        self.enabled = collector is not None

    def __enter__(self):
        if self.enabled:
            self.start = time.perf_counter_ns()
        return self

    def __exit__(self, *args):
        if self.enabled:
            duration = time.perf_counter_ns() - self.start
            self.collector[self.label].append(duration)
            if self.verbose:
                print(f"{self.label}: {duration / 1e6:.3f} ms")

#  print to file in a format that is compatible with cnp2cnp tool
def to_file(file, cells):
    with open(file, 'w') as f:
        for c in cells:
            f.write(">" + str(c.get_id()) + "\n")
            f.write(c.get_cnp() + "\n")


def use_cnp2cnp_to_compute_dist_matrix(sample=IN_FILE_NAME,
                                       folder=cnp2cnp_FOLDER, runfile=cnp2cnp_FILE,
                                       output=OUT_FILE_NAME):
    """
    Execute cnp2cnp. Input CNPs of cells and obtain evolutionary distance matrix of given cells.

    Parameters
    ----------
    sample : string
        name of the file that contains information about the cell sample; every cell is described in two lines:
        first describing id of the cell, begins with ">" (in example ">cell_0")
        second contains CNP profile as a list of values in a form "value1,value2,...,valueN",
        where N is the length of CNP
    folder : string
        name of the folder that contains cnp2cnp tool described in
        https://doi.org/10.1186/s12864-020-6611-3
        to manually set path where input file will be copied; output file generated before copied back;
    runfile : string
        name of the file to execute (cnp2cnp.py)
        to manually set path to the file
    output : string
        name of the output file that will be generated in location set in argument 'folder',
        and copied to current location.
        first line of the file contains the number N of cells
        the following N lines represent distance matrix, each line consist of the id of the cell
        and N values that are evolutionary distances to the corresponding cells;
        evolutionary distance is the minimal number of events to transform on cell (CNP) to another cell (CNP)

    Returns
    -------
        In the current directory generates a file which name is set in argument 'output'.
        The file will contain distance matrix of cells, which CNPs are given in file described by argument 'input'.
        The file is generated by an external tool cnp2cnp.
    """
    shutil.copy(sample, folder)     # copy file to the cnp2cnp project
    cnp2cnp_in = os.path.join(folder, sample)
    cnp2cnp_out = os.path.join(folder, output)
    pypath = str(sys.executable)
    # compute distance matrix for cnps using cnp2cnp
    subprocess.run([pypath, runfile, "-m", "matrix", "-i", cnp2cnp_in, "-o", cnp2cnp_out])
    # sample use: python cnp2cnp.py -m matrix -i examples/probka1.txt -o examples/o.txt
    shutil.copy(cnp2cnp_out, os.getcwd())   # copy file with results back


def get_cell_manualy(cell_list, value):
    for cell in cell_list:
        if cell.get_id() == value:
            return cell
    return None

def show_cells(cell_list):
    for cell_l in cell_list:
        print("Biopsy: ", [cell.cell_id for cell in cell_l])


def run_single_test(config="config_telomeric.json", bedfile="bed like config sample.csv", seed=777,
                    biopsy_size=2, biopsy_size_scalable=None, biopsy_generatons=[5,7,9], r_dist=4,
                    visualize=True, time_collector=None, clear_cnps=False):
    if bedfile is not None:
        sim = CancerCellEvolutionSimulator(config, bedfile, seed=seed)
    else:
        sim = CancerCellEvolutionSimulator(config, seed=seed)

    if time_collector is not None:
        with Timer("Core simulation: ", time_collector):
            sim.run_simulation()
    else:
        sim.run_simulation()

    cell_lists, all_in_one_sample = [], [[]]
    for b_gen in biopsy_generatons:
        biopsy = sim.perform_biopsy(biopsy_size=biopsy_size, biopsy_size_scalable=biopsy_size_scalable,
                                    generation=b_gen, seed=seed)
        cell_lists.append(biopsy)
        all_in_one_sample[0] += biopsy

    print("Number of biopsy cells: ", len(all_in_one_sample[0]))
    if len(all_in_one_sample[0]) < 3:
        print("Total number of cells in biopsy less than 3.")
        return

    to_file(IN_FILE_NAME, all_in_one_sample[0])
    print("Simulation finished. Generated cell evolution tree total nodes:", len(sim.tree.nodes()))
    if time_collector is not None:
        with Timer("Computing cnp2cnp distance matrix: ", time_collector):
            use_cnp2cnp_to_compute_dist_matrix(IN_FILE_NAME)
    else:
        use_cnp2cnp_to_compute_dist_matrix(IN_FILE_NAME)

    cl = deepcopy(cell_lists)
    osl = deepcopy(all_in_one_sample)
    # show_cells(cell_lists)

    # Options for True tree pic
    only_nodes = [0, 1, 3, 5, 4, 7, 13, 12, 19]
    if visualize:
        sim.plot_tree(biopsy_lists=cell_lists, legend_y_offset=-170,
                      highlight_nodes=all_in_one_sample[0], output_file="simulated_tree")
        sim.plot_tree(biopsy_lists=cell_lists,legend_y_offset=-170,
                      highlight_nodes=all_in_one_sample[0],extended=False,
                      only_nodes=only_nodes,node_numbers=True,output_file="true_tree")
    # if visualize:
    #     sim.plot_tree(biopsy_lists=cell_lists,legend_y_offset=-170,
    #                   highlight_nodes=all_in_one_sample[0])


    if clear_cnps:    # clear CNPs
        if time_collector is not None:
            with Timer("Clear CNPs: ", time_collector):
                true_tree_simplified = sim.tree_without_CNPs()
                for cell_list in cl:
                    for cell in cell_list:
                        cell.genome = []
                for cell in osl[0]:
                    cell.genome = []
    else:
        true_tree_simplified = sim.tree

    njtree, a1 = build_evolution_tree(osl, OUT_FILE_NAME, r=r_dist, only_nj=True)
    tree, a3 = build_evolution_tree(cl, OUT_FILE_NAME, r=r_dist)

    if visualize:
        lno = {2:[8,6], 1:[20,21,22,25,16,30], 0:[50,32,54,34,56,57,21,38,65,43,71,48]}
        visualize_tree_plotly(tree, a3, level_node_ordering=lno, output_file="reconstructed.html")
        lno1 = {0:[50,32,54,34,20,56,57,21,22,38,8,65,25,43,16,6,71,30,48]}
        visualize_tree_plotly(njtree, a1, level_node_ordering=lno1, output_file="nj.html")

        # print("GRF - check")
        # print(grf_tree(sim.tree, 0, sim.tree, 0))
        # print(grf_tree(tree, 0, tree, 0))
        # print(grf_tree(njtree, 0, njtree, 0))
    if time_collector is not None:
        with Timer("GRF our: ", time_collector):
            ret = grf_tree(true_tree_simplified, 0, tree, -1)
    else:
        ret = grf_tree(true_tree_simplified, 0, tree, -1)
    print("GRF - reconstructed: ", ret)

    if time_collector is not None:
        with Timer("GRF NJ: ", time_collector):
            ret = grf_tree(true_tree_simplified, 0, njtree, -1)
    else:
        ret = grf_tree(true_tree_simplified, 0, njtree, -1)
    print("GRF - all nodes NJ : ", ret)

        # allowed = [x.cell_id for x in all_in_one_sample[0]]
        # print("BGRF - reconstructed: ", bgrf_tree(true_tree_simplified, 0, tree, 0, allowed))
        # print("BGRF - all nodes NJ : ", bgrf_tree(true_tree_simplified, 0, njtree, 0, allowed))



if __name__ == "__main__":
    # seeds = [56, 777, 727, 7, 77, 22, 32]
    # for s in seeds:
    #     run_single_test(config="config_telomeric.json", bedfile=None, seed=s,
    #                     biopsy_size=0.5, biopsy_generatons=[5, 7, 9], r_dist=4, visualize=False)

    # r_list = [20, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100]
    # for r in r_list:
    #     print("Running simulation for r=", r)
    #     run_single_test(config="config_telomeric.json", bedfile=None, seed=22,
    #                 biopsy_size=0.5, biopsy_generatons=[5, 7, 9], r_dist=r, visualize=False)

    # timing_data = defaultdict(list)
    # seeds = [56, 777, 7, 77, 22, 32, 727, 0, 100, 1000]
    # for s in seeds:
    #     with Timer("Total", timing_data):
    #         run_single_test(config="config_telomeric.json", bedfile=None, seed=s, biopsy_size=2,
    #                         biopsy_generatons=[4, 7], r_dist=4, visualize=False,
    #                         time_collector=timing_data, clear_cnps=True)
    #
    # print("\nAverage durations (ms):")
    # for key, times in timing_data.items():
    #     avg_ms = sum(times) / len(times) / 1e6
    #     print(f"{key:<15}: {avg_ms:.3f} ms")

    run_single_test(config="config_for_pic.json", bedfile="pic.csv", seed=727,
                    biopsy_size_scalable=0.5, biopsy_generatons=[4, 6, 8], r_dist=4,
                    visualize=True)

    # run_single_test(config="config_for_pic.json", bedfile="pic.csv", seed=727,
    #                 biopsy_size_scalable=0.5, biopsy_generatons=[4, 7], r_dist=4,
    #                 visualize=True)
